#!/usr/bin/env node
"use strict";/* eslint-disable no-use-before-define */var fs=require("fs"),_require$option$optio=require("yargs").option("source",{alias:"s",describe:"Source file path"}).option("destination",{alias:["dest","d"],describe:"Path: where you want to store the output"}).demandOption(["source"],"Source file path is required").help(),argv=_require$option$optio.argv;startConversion(argv.source,argv.destination);/**
 * Start the conversion of source file and store it at the destination
 * Output file content could be submitted on any conding contest platform
 *
 * @param {*} source path
 * @param {*} destination path
 */function startConversion(a,b){var c=fs.readFileSync(a,"utf-8"),d=c.split("\n"),e=findInputReaderVariableName(d),f=getPrefixString(e),g=!0,h=!1,i=void 0;// Find the variable name in which inputReader is stored
// Read the file line by line
// eslint-disable-next-line no-restricted-syntax
try{for(var j,k=d[Symbol.iterator]();!(g=(j=k.next()).done);g=!0){var l=j.value,m=processLine(l,e);console.log("modifiedLine :",m),m&&(f+="\t"+m+"\n")}}catch(a){h=!0,i=a}finally{try{!g&&k.return&&k.return()}finally{if(h)throw i}}f+=getPostfixString(c,e),fs.writeFile(b,f,function(a){if(a)throw a;console.log("Hurray!!!! Output file generated successfully")})}/**
 * Process the single line of code written by user.
 *
 * @param {*} line
 * @param {*} nameOfInputReaderVariable
 * @returns
 */function processLine(a){/**
   * Remove the require statement
   */return /require.*\(.*competitive-programming-js.*\)/.test(a)?"":a}/**
 * Find the name of variable in which user store the inputReader object.
 * Which is used by user to read different types of input from the console.
 *
 * @param {*} Array of lines in code
 * @returns name of input reader variable
 */function findInputReaderVariableName(a){// eslint-disable-next-line no-restricted-syntax
var b=!0,c=!1,d=void 0;try{for(var e,f,g=a[Symbol.iterator]();!(b=(e=g.next()).done);b=!0){/**
     * Regex test for following type of require statement :
     * const { inputReader } = require('competitive-programming-js');
     * && exclude single or multiline comments
     */if(f=e.value,f=f.trim(),/^.*{.+}.*=.*require.*\(.*['"].*competitive-programming-js.*['"].*\)[ ]*;?[ ]*$/.exec(f)&&!/^([ ]*\/\/.*)|([ ]*\/\*.*\*\/[ ]*)$/.test(f)){/**
       * Below statement output :
       * [ 'const ', ' inputReader ', ' =' ]
       */var h=f.match(/{.*}/g)[0].replace(/([ ]*{[ ]*)|([ ]*}[ ]*)/g,"");return h}/**
     * const inputReader = require('competitive-programming-js').inputReader;
     */if(/^.*=.*require.*\(.*['"].*competitive-programming-js.*['"].*\).inputReader[ ]*;?[ ]*$/.exec(f)){/**
       * Below statement output :
       * [ 'const', 'inputReader', '=' ]
       */var i=f.match(/^.*=/g)[0].replace(/[ ]*=/,"").split(" ");return i[i.length-1]}}}catch(a){c=!0,d=a}finally{try{!b&&g.return&&g.return()}finally{if(c)throw d}}return null}/**
 * Get prefix for the converted code
 *
 * @param {*} input reader variable used by user
 * @returns prefix string
 */function getPrefixString(a){return"\nlet _inputLines;\nlet _lineNumber = 0;\nlet "+a+" = _inputReader ();\n\nfunction _main() {\n\t\n\t_inputLines = _inputData.trim().split('\\n').map((string) => {\n\t\treturn string.trim();\n\t});;\n"}/**
 * Get prefix for the converted code
 *
 * @param {*} code written by user
 * @param {*} nameOfInputReaderVariable
 * @returns postfix string
 */function getPostfixString(a,b){var c="\n}\n\nvar _inputData = '';\nfunction cacheInput(data) {\n\t_inputData += data;\n}\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', cacheInput).on('end', _main);\n\nfunction _inputReader () {",d="\n\treturn {";return a.includes(b+".readArray()")&&(c+="\n\tfunction readArray() {\n\t\treturn _inputLines[_lineNumber++].split(' ');\n\t}\n\t\t",d+="\n\t\treadArray,"),a.includes(b+".readBoolean()")&&(c+="\n\tfunction readBoolean(){\n\t\tlet word = _inputLines[_lineNumber++];\n\t\tif(word.toLowerCase() == \"true\" || word.toLowerCase() == \"1\"){\n\t\t\treturn true;\n\t\t}else {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\t",d+="\n\t\treadBoolean,"),a.includes(b+".readChar()")&&(c+="\n\tfunction readChar(){\n\t\treturn _inputLines[_lineNumber++].trim();\n\t}\n\t\t",d+="\n\t\treadChar,"),a.includes(b+".readNumber()")&&(c+="\n\tfunction readNumber(){\n\t\treturn Number(_inputLines[_lineNumber++]);\n\t}\n\t\t",d+="\n\t\treadNumber,"),a.includes(b+".readLine()")&&(c+="\n\tfunction readLine(){\n\t\treturn _inputLines[_lineNumber++];\n\t}\n\t\t",d+="\n\t\treadLine,"),a.includes(b+".readNumberArray()")&&(c+="\n\tfunction readNumberArray(){\n\t\treturn _inputLines[_lineNumber++].split(' ').map(val => Number(val));\n\t}\n\t\t",d+="\n\t\treadNumberArray,"),d+="\n\t}",c+="\n\t"+d+"\n}",c}